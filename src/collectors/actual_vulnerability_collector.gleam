// OSV API vulnerability collector
// Fetches and decodes vulnerability data from OSV API

import gleam/dynamic/decode
import gleam/http/request
import gleam/http/response
import gleam/httpc
import gleam/json
import gleam/option.{type Option, None, Some}
import gleam/result
import gleam/string

pub type OSVVulnerability {
  OSVVulnerability(
    id: String,
    published: String,
    modified: String,
    references: List(Reference),
    affected: List(AffectedPackage),
  )
}

pub type AffectedPackage {
  AffectedPackage(
    package: OSVPackage,
    versions: List(String),
    ranges: List(Range),
  )
}

pub type OSVPackage {
  OSVPackage(ecosystem: String, name: String)
}

pub type Range {
  Range(range_type: String, events: List(Event))
}

pub type Reference {
  Reference(ref_type: String, url: String)
}

pub type Event {
  Event(introduced: Option(String), fixed: Option(String))
}

// https://osv-vulnerabilities.storage.googleapis.com/<ECOSYSTEM>/<ID>.json
// example id format "Debian/CVE-2020-35511\r", "Alpine/CVE-2022-29824\r", "Go/GHSA-95v9-hv42-pwrj\r", "Debian/CVE-2025-30224\r", "GIT/CVE-2022-29824\r"
pub fn actual_vulnerability_collector(
  vulnerability_id: String,
) -> Result(String, String) {
  let url =
    "https://osv-vulnerabilities.storage.googleapis.com/"
    <> string.trim(vulnerability_id)
    <> ".json"

  use base_request <- result.try(
    request.to(url)
    |> result.map_error(fn(_) { "Invalid URL" }),
  )
  let req = request.prepend_header(base_request, "accept", "application/json")
  use resp <- result.try(
    httpc.send(req)
    |> result.map_error(fn(e) { "HTTP client error: " <> string.inspect(e) }),
  )

  // Check status code
  case resp.status {
    200 -> {
      // Check content type
      case response.get_header(resp, "content-type") {
        Ok(content_type) -> {
          case string.starts_with(content_type, "application/json") {
            True -> Ok(resp.body)
            False -> Error("Invalid content type")
          }
        }
        Error(_) -> Error("Missing content-type header")
      }
    }
    _ -> Error("HTTP status: " <> string.inspect(resp.status))
  }
}

fn osv_package_decoder() {
  use ecosystem <- decode.field("ecosystem", decode.string)
  use name <- decode.field("name", decode.string)
  decode.success(OSVPackage(ecosystem:, name:))
}

fn affected_package_decoder() {
  use package <- decode.field("package", osv_package_decoder())
  use versions <- decode.field(
    "versions",
    decode.optional(decode.list(decode.string)),
  )
  use ranges <- decode.field(
    "ranges",
    decode.optional(decode.list(range_decoder())),
  )
  decode.success(AffectedPackage(
    package:,
    versions: versions |> option.unwrap([]),
    ranges: ranges |> option.unwrap([]),
  ))
}

fn reference_decoder() {
  use ref_type <- decode.field("type", decode.string)
  use url <- decode.field("url", decode.string)
  decode.success(Reference(ref_type:, url:))
}

fn event_decoder() {
  // 各イベントは introduced か fixed のどちらか一方のみを持つ
  let introduced_decoder = {
    use introduced <- decode.field("introduced", decode.string)
    decode.success(Event(introduced: Some(introduced), fixed: None))
  }
  let fixed_decoder = {
    use fixed <- decode.field("fixed", decode.string)
    decode.success(Event(introduced: None, fixed: Some(fixed)))
  }
  decode.one_of(introduced_decoder, or: [fixed_decoder])
}

fn range_decoder() {
  use range_type <- decode.field("type", decode.string)
  use events <- decode.field("events", decode.list(event_decoder()))
  decode.success(Range(range_type:, events:))
}

pub fn decode_osv_vulnerability(
  target_json: String,
) -> Result(OSVVulnerability, json.DecodeError) {
  let json_decoder = {
    use id <- decode.field("id", decode.string)
    use published <- decode.field("published", decode.string)
    use modified <- decode.field("modified", decode.string)
    use references <- decode.field(
      "references",
      decode.list(reference_decoder()),
    )
    use affected <- decode.field(
      "affected",
      decode.list(affected_package_decoder()),
    )
    decode.success(OSVVulnerability(
      id:,
      published:,
      modified:,
      references:,
      affected:,
    ))
  }
  json.parse(from: target_json, using: json_decoder)
}

// Public function to fetch and decode vulnerability from OSV API
pub fn fetch_and_decode_vulnerability(
  vulnerability_id: String,
) -> Result(Option(OSVVulnerability), String) {
  case actual_vulnerability_collector(vulnerability_id) {
    Ok(json_body) ->
      case decode_osv_vulnerability(json_body) {
        Ok(vulnerability) -> Ok(Some(vulnerability))
        Error(decode_error) ->
          Error("Failed to decode JSON: " <> string.inspect(decode_error))
      }
    Error(http_error) ->
      Error("HTTP request failed: " <> string.inspect(http_error))
  }
}
