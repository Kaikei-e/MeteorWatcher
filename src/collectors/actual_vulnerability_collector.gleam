// OSV API vulnerability collector
// Fetches and decodes vulnerability data from OSV API

import gleam/dynamic/decode
import gleam/http/request
import gleam/httpc
import gleam/json
import gleam/list
import gleam/option.{type Option, Some}
import gleam/result
import gleam/string

pub type OSVVulnerability {
  OSVVulnerability(
    id: String,
    published: String,
    modified: String,
    references: List(String),
    affected: List(AffectedPackage),
  )
}

pub type AffectedPackage {
  AffectedPackage(
    package: OSVPackage,
    versions: List(String),
    ranges: List(Range),
  )
}

pub type OSVPackage {
  OSVPackage(ecosystem: String, name: String)
}

pub type Range {
  Range(range_type: String, repo: String, events: List(Event))
}

pub type Event {
  Event(introduced: String, fixed: String)
}

pub fn actual_vulnerability_collector(
  vulnerability_id: String,
) -> Result(String, httpc.HttpError) {
  let status_ok = 200
  let url = "https://api.osv.dev/v1/vulns/" <> vulnerability_id

  let assert Ok(base_request) = request.to(url)
  let req = request.prepend_header(base_request, "accept", "application/json")
  use resp <- result.try(httpc.send(req))

  // We get a response record back
  assert resp.status == status_ok

  let content_type =
    resp.headers |> list.find(fn(header) { header.0 == "content-type" })
  assert content_type == Ok(#("content-type", "application/json"))

  assert resp.status == status_ok
  Ok(resp.body)
}

fn osv_package_decoder() {
  use ecosystem <- decode.field("ecosystem", decode.string)
  use name <- decode.field("name", decode.string)
  decode.success(OSVPackage(ecosystem:, name:))
}

fn event_decoder() {
  // Simplified: expect both fields, use empty string if not present
  use introduced <- decode.field("introduced", decode.string)
  use fixed <- decode.field("fixed", decode.string)
  decode.success(Event(introduced:, fixed:))
}

fn range_decoder() {
  use range_type <- decode.field("type", decode.string)
  use repo <- decode.field("repo", decode.string)
  use events <- decode.field("events", decode.list(event_decoder()))
  decode.success(Range(range_type:, repo:, events:))
}

fn affected_package_decoder() {
  use package <- decode.field("package", osv_package_decoder())
  use versions <- decode.field("versions", decode.list(decode.string))
  use ranges <- decode.field("ranges", decode.list(range_decoder()))
  decode.success(AffectedPackage(package:, versions:, ranges:))
}

fn reference_decoder() {
  use url <- decode.field("url", decode.string)
  decode.success(url)
}

pub fn decode_osv_vulnerability(
  target_json: String,
) -> Result(OSVVulnerability, json.DecodeError) {
  let json_decoder = {
    use id <- decode.field("id", decode.string)
    use published <- decode.field("published", decode.string)
    use modified <- decode.field("modified", decode.string)
    use references <- decode.field(
      "references",
      decode.list(reference_decoder()),
    )
    use affected <- decode.field(
      "affected",
      decode.list(affected_package_decoder()),
    )
    decode.success(OSVVulnerability(
      id:,
      published:,
      modified:,
      references:,
      affected:,
    ))
  }
  json.parse(from: target_json, using: json_decoder)
}

// Public function to fetch and decode vulnerability from OSV API
pub fn fetch_and_decode_vulnerability(
  vulnerability_id: String,
) -> Result(Option(OSVVulnerability), String) {
  case actual_vulnerability_collector(vulnerability_id) {
    Ok(json_body) ->
      case decode_osv_vulnerability(json_body) {
        Ok(vulnerability) -> Ok(Some(vulnerability))
        Error(decode_error) ->
          Error("Failed to decode JSON: " <> string.inspect(decode_error))
      }
    Error(http_error) ->
      Error("HTTP request failed: " <> string.inspect(http_error))
  }
}
